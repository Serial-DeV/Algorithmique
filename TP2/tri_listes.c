/*******************************************************************************//* Fichier listes.c                                                            *//* cree le 27/11/2018 par Alix Munier Kordon                                   *//* Ce fichier contient la declaration des fonctions de tri de liste            *//*******************************************************************************/#include <math.h>#include <stdio.h>#include <stdlib.h>#include "tri_listes.h"/*******************************************************************************//* PTRCELLULE triInsertion(PTRCELLULE tete)                                    *//* Tri tete par insertion                                                      *//* retourne l'adresse de la liste triee                                        *//*******************************************************************************/PTRCELLULE triInsertion(PTRCELLULE tete){	return tete;}/*******************************************************************************//* PTRCELLULE triSelection(PTRCELLULE tete)                                    *//* Tri tete par selection                                                      *//* retourne l'adresse de la liste triee                                        *//*******************************************************************************/PTRCELLULE triSelection(PTRCELLULE tete){	return tete;}		/*******************************************************************************//* PTRCELLULE eclatement  (PTRCELLULE tete, PTRCELLULE* pInf, PTRCELLULE* psup)*//* Eclate la liste non vide pointee par tete en 3 sous-listes:                 *//* pinf est l'adresse de la tete de la liste des elements strictement plus     *//* petits que la premiere cellule de tete                                      *//* psup est l'adresse de la tete de la liste des elements  plus                *//* grands que la premiere cellule de tete                                      *//* La fonction renvoie la premiere cellule de tete                             *//*******************************************************************************/		PTRCELLULE eclatement  (PTRCELLULE tete, PTRCELLULE* pInf, PTRCELLULE* pSup){		PTRCELLULE aux;	PTRCELLULE succ;	aux = tete->suiv;	tete->suiv = NULL;		while(aux) {		succ=aux->suiv;		aux->suiv=NULL;		if(aux->val < tete->val) {			printf("Eclatement- %d\n",aux->val );			*pInf = concatenation(*pInf, aux);			printf("\npInf\n");			affiche(*pInf);printf("\n");		}		else {printf("Eclatement+ %d\n",aux->val );			*pSup = concatenation(*pSup, aux);			printf("\npSup\n");			affiche(*pSup);printf("\n");		}		aux = succ;	}			return tete;}/*******************************************************************************//* PTRCELLULE QuickSort(PTRCELLULE tete)                                       *//* Tri tete par Quicksort                                                      *//* retourne l'adresse de la liste triee                                        *//*******************************************************************************/PTRCELLULE QuickSort(PTRCELLULE tete){	if(tete == NULL) return NULL;	PTRCELLULE pivot = NULL;	PTRCELLULE aux = tete;	PTRCELLULE pInf = NULL;	PTRCELLULE pSup = NULL;	pivot = eclatement(aux, &pInf, &pSup);	pInf = QuickSort(pInf);	pSup = QuickSort(pSup);	tete = concatenation(pInf, pivot);	tete = concatenation(tete, pSup);	return tete;}/*******************************************************************************//* PTRCELLULE eclatementBis(PTRCELLULE tete, PTRCELLULE* pInf, PTRCELLULE* psup)*//* Eclate la liste non vide pointee par tete en 3 sous-listes:                 *//* pinf est l'adresse de la tete de la liste des elements strictement plus     *//* petits que la premiere cellule de tete                                      *//* psup est l'adresse de la tete de la liste des elements  plus                *//* grands que la premiere cellule de tete                                      *//* La fonction renvoie la premiere cellule de tete                             *//*******************************************************************************/		PTRCELLULE eclatementBis  (PTRCELLULE tete, PTRCELLULE* pInf, PTRCELLULE* pSup){	PTRCELLULE aux;	PTRCELLULE succ;	aux = tete->suiv;	tete->suiv = NULL;		while(aux) {		succ=aux->suiv;		aux->suiv=NULL;		if(aux->val < tete->val) {			PTRCELLULE tmp = *pInf;			if(!*pInf) return aux;			while(tmp->suiv != NULL) {				tmp = tmp->suiv;			}			if(tmp->suiv == NULL)				tmp->suiv = aux;		}		else {			PTRCELLULE tmp = *pSup;			if(!*pSup) return aux;			while(tmp->suiv != NULL) {				tmp = tmp->suiv;			}			if(tmp->suiv == NULL)				tmp->suiv = aux;		}		aux = succ;	}	return tete;}/*******************************************************************************//* void divsion(PTRCELLULE tete, PTRCELLULE* pL1, PTRCELLULE* pL2)             *//* Eclate la liste pointee par tete en deus sous listes pointees par           *//* *pL1 et *pL2                                                                *//* on gardera l'Ã©dresse de la derniere celleule inseree pour effectuer         *//* une insertion en queue en theta(1)                                          *//*******************************************************************************/void divsion(PTRCELLULE tete, PTRCELLULE* pL1, PTRCELLULE* pL2) {	PTRCELLULE tmp = tete;	PTRCELLULE tmp1 = (*pL1)->suiv;	PTRCELLULE tmp2 = (*pL2)->suiv;		while(tmp->suiv){		tmp = tmp->suiv;		tmp1->val = tmp->val;		tmp1 = tmp1->suiv;		if(tmp->suiv){			tmp = tmp->suiv;			tmp2->val = tmp->val;			tmp2=tmp2->suiv;		}	}}	/*******************************************************************************//* PTRCELLULE fusionTriee(PTRCELLULE L1, PTRCELLULE L2)                        *//* Fusionne les deux listes triees L1 et L2 en une troisieme trie et           *//* la renvoie                                                                  *//*******************************************************************************/PTRCELLULE fusionTriee(PTRCELLULE L1, PTRCELLULE L2) {	return L1;}/*******************************************************************************//* PTRCELLULE TriFusion(PTRCELLULE tete)                                       *//* Tri tete par Fsuin                                                          *//* retourne l'adresse de la liste triee                                        *//*******************************************************************************/PTRCELLULE triFusion (PTRCELLULE tete){	return tete;}			