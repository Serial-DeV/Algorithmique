/*******************************************************************************//* Fichier listes.c                                                            *//* cree le 27/11/2018 par Alix Munier Kordon                                    *//* Ce fichier contient la declaration des fonctions des gestion d'une liste    *//*******************************************************************************/#include <stdlib.h>#include <stdio.h>#include "listes.h"  /*******************************************************************************//* PTRCELLULE creation(int valeur)                                             *//* Creation d'une CELLULE                                                      *//* Renvoie l'adresse de CALLULE cree, NULL sinon                               *//*******************************************************************************/PTRCELLULE creation(int valeur) {	PTRCELLULE aux;		aux=(PTRCELLULE)malloc(sizeof(CELLULE));		if (!aux) return NULL;		aux->val=valeur;	aux->suiv=NULL;	return aux;}	/*******************************************************************************//* PTRCELLULE insertionTete(PTRCELLULE tete, PTRCELLULE element)               *//* insere la cellule element non vide en tete de la liste d'aresse tete        *//* Renvoie l'adresse de la nouvelle liste                                      *//*******************************************************************************/PTRCELLULE insertionTete(PTRCELLULE tete, PTRCELLULE element)  {	element->suiv=tete;	return element;}	/*******************************************************************************//* PTRCELLULE suppressionTete(PTRCELLULE* adrtete)                             *//* enleve la cellule de tete de la liste pointee par *adrtete                  *//* Retourne l'adresse de la cellule retiree si la liste est non vide,          *//* NULL sinon.                                                                 *//*******************************************************************************/PTRCELLULE suppressionTete(PTRCELLULE* adrtete){	PTRCELLULE aux;		if ((*adrtete)==NULL) return NULL;		aux=(*adrtete);	(*adrtete)=aux->suiv;	aux->suiv=NULL;		return aux;}/*******************************************************************************//* PTRCELLULE insertionTriee(PTRCELLULE tete, PTRCELLULE element)              *//* insere la cellule pointee par element a sa place dans la liste              *//* pointee par tete                                                            *//* Retourne l'adresse de la nouvelle liste                                     *//*******************************************************************************/PTRCELLULE insertionTriee(PTRCELLULE tete, PTRCELLULE element){	PTRCELLULE prec, cour;		prec=NULL;	cour=tete;		while (cour && (cour->val <= element->val))	{		prec=cour;		cour=cour->suiv;	}	element->suiv=cour;		if (!prec)               // si insertion en tete		return element;		prec->suiv=element;	return tete;}/*******************************************************************************//* int suppression(PTRCELLULE* adrtete, PTRCELLULE element)                    *//* supprime la cellule pointee par element de la liste pointee par (*adrtete)  *//* Retourne 0 si element n'est pas dans la liste, 1 sinon.                     *//* La cellule pointee par element nest pas detruite.                           *//*******************************************************************************/int suppression(PTRCELLULE* adrtete, PTRCELLULE element){	PTRCELLULE prec, cour;		cour=(*adrtete);	prec=NULL;		while(cour && cour!=element)	{		prec=cour;		cour=cour->suiv;	}	if (!cour) //element n est pas dans la liste		return 0;		if (!prec)		(*adrtete)=cour->suiv;	else		prec->suiv=cour->suiv;		element->suiv=NULL;	return 1;}/*******************************************************************************//* PTRCELLULE rechercheMax(PTRCELLULE tete)                                    *//* retourne l'adresse du plus grand element de la liste tete si tete est non   *//* nulle, NULL sinon.                                                          *//*******************************************************************************/PTRCELLULE rechercheMax(PTRCELLULE tete){	if (tete->suiv == NULL)	{		return NULL;	}	PTRCELLULE ptrMax = tete;	PTRCELLULE ptrParc = tete->suiv;	while(ptrParc->suiv){		ptrParc = ptrParc->suiv;		if (ptrParc->val >= ptrMax->val)		{			ptrMax = ptrParc;		}	}	return ptrMax;}/*******************************************************************************//* PTRCELLULE supprimeListe(PTRCELLULE tete)                                   *//* Detruit la liste pointee par tete et retourne NULL                          *//*******************************************************************************/PTRCELLULE supprimeListe(PTRCELLULE tete){	PTRCELLULE aux, cour;		cour=tete;	while (cour)	{		aux=cour;		cour=cour->suiv;		free(aux);	}	return NULL;}/*******************************************************************************//* Pvoid affiche (PTRCELLULE tete)                                             *//* Affiche les valeurs stockÃ©es dans tete dans l'ordre de la liste             *//*******************************************************************************/void affiche (PTRCELLULE tete){	if (tete->suiv != NULL) {        printf(" %d", tete->val);        affiche (tete->suiv);    }    else                printf(" %d", tete->val);}/*******************************************************************************//* PTRCELLULE insertionTrieeRec(PTRCELLULE tete, PTRCELLULE element)           *//* insere la cellule pointee par element a sa place dans la liste              *//* pointee par tete                                                            *//* Retourne l'adresse de la nouvelle liste                                     *//*******************************************************************************/PTRCELLULE insertionTrieeRec(PTRCELLULE tete, PTRCELLULE element){	if(!tete || tete->val >= element->val){		tete = insertionTete(tete, element);		return tete;	}	return insertionTete(insertionTrieeRec(tete->suiv, element), tete);}/*******************************************************************************//* PTRCELLULE insertionQueue(PTRCELLULE tete, PTRCELLULE element)              *//* insere la cellule pointee par element en queu dans la liste                 *//* pointee par tete                                                            *//* Retourne l'adresse de la nouvelle liste                                     *//*******************************************************************************/PTRCELLULE insertionQueue(PTRCELLULE tete, PTRCELLULE element){		PTRCELLULE cour = tete;	element->suiv = NULL;	if(!tete){		return element;	}	while(cour->suiv){		cour = cour->suiv;	}	cour->suiv = element;	return tete;}/*******************************************************************************//* PTRCELLULE inverserListe(PTRCELLULE tete)                                   *//* inverse l'ordre des element de la liste pointee par tete                    *//* Retourne l'adresse de la nouvelle liste                                     *//*******************************************************************************/PTRCELLULE inverserListe(PTRCELLULE tete){	if(tete->suiv == NULL){		return tete;	}	return insertionQueue(inverserListe(tete->suiv), tete);}/*******************************************************************************//* PTRCELLULE dernierElement(PTRCELLULE tete)                                  *//* retourne l'adresse du dernier element de la liste tete si tete est non      *//* nulle, NULL sinon.                                                          *//*******************************************************************************/PTRCELLULE dernierElement(PTRCELLULE tete){	if (tete->suiv)	{			dernierElement(tete->suiv);	}	else	return tete;}/*******************************************************************************//* int estPalindrome(PTRCELLULE tete, PTRCELLULE queue)                        *//* vri si la liste cemprise entre tete et queue est un palindrome              *//*******************************************************************************/int estPalindrome(PTRCELLULE ptete, PTRCELLULE pqueue)       {	return 0;}PTRCELLULE rechercheMin(PTRCELLULE tete){	if (tete->suiv == NULL)	{		return NULL;	}	PTRCELLULE ptrMin = tete;	PTRCELLULE ptrParc = tete->suiv;	while(ptrParc->suiv){		ptrParc = ptrParc->suiv;		if (ptrParc->val < ptrMin->val)		{			ptrMin = ptrParc;		}	}	return ptrMin;}